import subprocess
from typing import Tuple, List
import gym
from transformers import AutoTokenizer, AutoModelForCausalLM, pipeline
from omegaconf import DictConfig
import logging

# Wrapper für die Interaktion mit den LLM-Modellen
class LLMClient:
    def __init__(self, config: DictConfig):
        tokenizer_command = AutoTokenizer.from_pretrained(config.model_path)
        command_model = AutoModelForCausalLM.from_pretrained(config.model_path, device_map='auto', load_in_8bit=True)
        self.command_model = pipeline("text-generation", model=command_model, tokenizer=tokenizer_command, return_full_text=False, **config.generation_args)


    def action_to_command(self, action: str) -> str:
        command_prompt = (f"Extract a single concise terminal command from the following input {action}. "
                          f"Provide only the command itself to execute it in a Terminal, without any additional characters, explanation.")
        command = self.command_model(command_prompt)
        command = command[0]['generated_text']
        lines = command.split('\n')
        non_empty_lines = [line for line in lines if line.strip() != '']
        lines = '\n'.join(non_empty_lines)
        lines = self._remove_input_text(lines, "Command: ")
        lines = self._remove_input_text(lines, "Final answer: ")
        lines = self._remove_input_text(lines, "Answer: ")
        lines = self._remove_input_text(lines, "```")
        lines = self._remove_input_text(lines, "\n")
        lines = self._remove_input_text(lines, "`")
        return lines

    def _remove_input_text(self, text: str, text_to_remove: str) -> str:
        return text.replace(text_to_remove, '')


class PentestEnvLLM(gym.Env):
    def __init__(self, config: DictConfig):
        super().__init__()
        self.llm_client = LLMClient(config.llm_client)
        self.current_observation = ""
        self.commands = []
        self.logger = logging.getLogger('PentestEnv')

    def step(self, action: str) -> Tuple[str, int, bool, dict]:
        # Wandelt die Aktion in einen Terminalbefehl um
        command = self.llm_client.action_to_command(action)
        output = self._execute_command(command)
        reward = self._evaluate_output(output, command, action)
        done = self._check_if_done(output)
        return output, reward, done, {}

    def _execute_command(self, command: str) -> str:
        self.logger.info(f"Command: {command}")
        try:
            timeout_duration = 60
            completed_process = subprocess.run(command, shell=True, capture_output=True, text=True,
                                               timeout=timeout_duration)
            if completed_process.stderr:
                return completed_process.stderr.strip()
            else:
                return completed_process.stdout.strip()
        except subprocess.TimeoutExpired:
            self.logger.info("Timeout")
            return "Timeout: The command took too long and was canceled."
        except subprocess.CalledProcessError as e:
            return f"Errorcode: {e.returncode}, Error message: {e.output}"

    def _evaluate_output(self, output: str, command: str, action: str) -> int:
        # Bewertet die Terminalausgabe, um die Belohnung zu bestimmen
        first_word = command.split()
        if action == "":
            return -0.8
        if len(first_word) == 0:
            return -0.8
        else:
            self.commands.append(first_word[0])

        if "help" in output or "command not found" in output or "Errorcode" in output:  # Bestrafung für falsche Befehle
            self.logger.info("Error found")
            return  -1.0
        elif "flag{access_the_machine}" in output:  # Belohnung für das Finden der Flagge
            return 1.0
        elif "success" in output or "completed" in output:
            return 0.5
        elif output == "" or command == "":
            return -0.8
        elif self._check_occurrences_in_list(self.commands, first_word[0]) and "Timeout" in output:
            return -0.8
        elif "Timeout" in output:
            return -0.6
        elif "Unable" in output:
            return -0.5
        elif self._check_occurrences_in_list(self.commands, first_word[0]):  # Befehl zählen und bei 3x Bestrafen
            return -0.7
        else:
            return -0.1

    def _check_occurrences_in_list(self, word_list: List[str], target: str) -> bool:
        threshold = 3
        count = word_list.count(target)
        return count >= threshold
  
    def _check_if_done(self, output: str) -> bool:
        # Prüft, ob das Ziel erreicht wurde
        return "flag.txt" in output

    def reset(self) -> str:
        # Setzt die Umgebung zurück
        self.current_observation = ""
        return self.current_observation